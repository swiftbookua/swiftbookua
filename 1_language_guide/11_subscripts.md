## ІндексиКласи, структури та перечислення можуть визначати *індекси*, що є скороченим синтаксисом для доступу до елементів колекції, списку чи послідовності. Індекси використовуються для присвоєння чи отримання значення за індексом без потреби у створенні окремих методів для присвоєння чи отримання. Наприклад, коли ви звертаєтесь до елементів масиву `Array` як `someArray[index]`, або до елементу в словнику `Dictionary` як `someDictionary[key]`, ви користуєтесь індексами. Можна створювати кілька різних індексів для одного типу, і потрібна версія індексу буди вибрана, базуючись на типі значення, що передається у індекс. Індекси не обмежені одним виміром, можна створювати індекси, що приймають декілька вхідних параметрів, щоб відповідати потребам вашого власного типу. ### Синтаксис індексаціїІндекси дозволяють робити запити до екземплярів типу, записуючи одне чи більше значень в квадратних дужках після імені екземпляру. Їх синтаксис подібний одночасно до синтаксису методів екземпляру та властивостей, що обчислюються. Оголшення індексу починається із ключового слова `subscript`, після чого вказуються один чи кілька вхідних параметрів та тип, що повертається, так само, як і в методах екземпляру. На відміну від методів екземпляру, індекси бувають двох видів: для читання й запису, та тільки для читання. Така поведінка передається геттером і сеттером, аналогічно до властивостей, що обчислюються: ```swiftsubscript(index: Int) -> Int {    get {        // відповідне значення індексу повертаєтсья тут    }    set(newValue) {        // присвоєння нового значення відбувається тут    }}```Тип параметра `newValue` співпадає із типом значення, що повертає індекс. Як і у властивостях, що обчислюються, можна не вказувати параметр сеттера `(newValue)`. В такому разі у сеттер неявно передаватиметься параметр із іменем за замовчанням `newValue`.Як і з властивостями тільки для читання, що обчислюються, можна пропустити ключове слово `get`:```swiftиsubscript(index: Int) -> Int {    // return an appropriate subscript value here}```

Ось приклад реалізації індексу тільки для читання, що дозволяє структурі `TimesTable` представляти таблицю множення на довільне ціле число:```swiftstruct TimesTable {    let multiplier: Int    subscript(index: Int) -> Int {        return multiplier * index    }}let threeTimesTable = TimesTable(multiplier: 3)print("шість помножити на три дорівнює \(threeTimesTable[6])")// Надрукує "шість помножити на три дорівнює 18"```

У даному прикладі створюється новий екземпляр структури `TimesTable` для представлення таблиці множення на три. Це задається передачею значення `3` до ініціалізатора структури `TimesTable` як значення для ініціалізації властивості `multiplier`. Тепер можна робити запити до екземпляру `threeTimesTable` шляхом звернення до індексу, як показано у виклику  `threeTimesTable[6]`. У цьому виклику запитується шостий рядок у таблиці множення на три, що поветрає значення `18`, або `3` помножити на `6`.> **Примітка**> 
> Таблиця множення на ціле число базується на фіксованому математичному правилі, тому недоречно присвоювати `threeTimesTable[someIndex]` нове значення, і тому даний індекс в `TimesTable` було оголошено як індекс тільки для читання. 
### Використання індексів

Точний зміст “індексу” залежить від контексту, в якому його використовують. Індекси, як правило, застосовуються як скорочений синтаксис для доступу до елементів у колекції, списку чи послідовності. Ви можете реалізовувати індекси у найбільш властивий для функціональності кожного конкретного класу чи структури спосіб. Наприклад, тип `Dictionary` у Swift реалізовуює індекс для присвоєння та доступу до значень, що зберігаються в екземплярі `Dictionary`. Можна задати значення у словнику, вказавни ключ відповідного типу в квадратних дужках індексу, та присвоївши значення відповідного типу:```swiftvar numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]numberOfLegs["bird"] = 2```

У прикладі вище визначено змінну на ім'я `numberOfLegs`, яку ініціалізовано літералом словника, що містить три пари ключ-значення. Тип словника `numberOfLegs` визначено компілятором як `[String: Int]`. Після створення словника, у прикладі використовується індекс для додавання до словника ключа `"bird"` типу `String` та відповідного йому значення `2` типу `Int`.Детальнішу інформацію про індексацію словників можна знайти у підрозділі [Доступ до елементів словника та його модифікація](3_collection_types.md#Доступ-до-елементів-словника-та-його-имодифікація).> **Примітка**> 
> У Swift тип `Dictionary` реалізовує індексацію ключ-значення за допомогою індексу, що приймає та повертає *опціональний тип*. У словнику `numberOfLegs` вище, індекс приймає та повертає значення типу `Int?`, або “опціональний int”. Тип `Dictionary` використовує опціональний тип індекса для моделювання факту, що не кожен ключ має значення, і для можливості видаляти значення для заданого ключа шляхом присвоєння значення `nil` для цього ключа.

### Опції індексів

Індекси можуть мати будь-яку кількість вхідних параметрів, і ці вхідні параметри можуть мати будь-який тип. Індекси також можуть повертати будь-який тип. Індекси можуть мати варіативні параметри, але вони не можуть мати двонаправлених параметрів, а параметри індексів не можуть мати значення за замовчанням. 

Клас чи структура може містити стільки реалізації індекси, скільки йому або їй потрібно; при цьому потрібна реалізація визначиться компілятором за типом значення чи значень, що містяться в квадратних дужках індексу в момент використання індексу. Ця можливість існування кількох індексів називається *перевантаженням індексів*. 

Хоча найчастіше індекси приймають єдиний параметр, можна створювати індекси із кількома параметрами, якщо це підходить для даного типу. У наступному прикладі оголошено структуру `Matrix`, що представляє двовимірну матрицію значень типу `Double`. Індекс структури `Matrix` приймає два цілочисельних параметри:
```swiftstruct Matrix {    let rows: Int, columns: Int    var grid: [Double]    init(rows: Int, columns: Int) {        self.rows = rows        self.columns = columns        grid = Array(repeating: 0.0, count: rows * columns)    }    func indexIsValid(row: Int, column: Int) -> Bool {        return row >= 0 && row < rows && column >= 0 && column < columns    }    subscript(row: Int, column: Int) -> Double {        get {            assert(indexIsValid(row: row, column: column), "Index out of range")            return grid[(row * columns) + column]        }        set {            assert(indexIsValid(row: row, column: column), "Index out of range")            grid[(row * columns) + column] = newValue        }    }}```

Структура `Matrix` містить ініціалізатор, що приймає два параметри `rows` та `columns` (кількість рядків та стовпчиків відповідно), і створює масив, достатньо великий для зберігання `rows * columns` значень типу `Double`. Кожна позиція в матриці отримує початкове значення `0.0`. Щоб досягнути цього, розмір масиву та початкове значення `0.0` передаються в ініціалізатор масиву, котрий створює та ініціалізує новий масив відповідного розміру. Цей ініціалізатор детальніше описано в підрозділі [Створення масиву із значення за замовчанням](3_collection_types.md#Створення-масиву-із-значення-за-замовчанням).Тепер можна створити новий екземпляр структури `Matrix`, передавши потрібну кількість рядків та стовпчиків в її ініціалізатор:```swiftvar matrix = Matrix(rows: 2, columns: 2)```У попередньому прикладі створено новий екземпляр структури `Matrix` із двома рядочками та двома стовпчиками. Масив `grid` у цьому екземплярі фактично містить пласку розгортку матриці, ніби її вміст було прочитано зверху вниз зліва направо:![](images/subscriptMatrix01_2x.png)

Значення у матриці можна задати, передаючи рядок та стовпчик до індексу, розділивши їх комою:￼```swiftmatrix[0, 1] = 1.5matrix[1, 0] = 3.2```Ці дві інструкції викликають сеттер індекса, і задають значення `1.5` у верхній правій позиції матриці (де `row` дорівнює `0` та `column` дорівнює `1`), та значення `3.2` у нижній лівій позиції (де `row` дорівнює `1` та `column` дорівнює `0`):
![](images/subscriptMatrix02_2x.png)Сеттер та геттер індексу структури `Matrix` містять `assert`, котрий перевіряє, що передані параметри `row` та `column` є коректними. Щоб спростити ці перевірки `assert`, структура `Matrix` містить метод для зручності, що називається `indexIsValid(row:column:)`. Цей метод перевіряє, чи є задані `row` та `column` в межах розмірів матриці:```swiftfunc indexIsValidForRow(row: Int, column: Int) -> Bool {    return row >= 0 && row < rows && column >= 0 && column < columns}```Якщо спробувати звернутись до індексу за межами розмірів матриці, спрацює `assert`:```swiftlet someValue = matrix[2, 2]
// Цей код спровокує assert, оскільки [2, 2] лежить за межами розмірів матриці.```