# ÐšÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ñ–ÑÑ‚ÑŒ

ðŸš§ ÐÐ°Ñ€Ð°Ð·Ñ– Ñ‚Ñ€Ð¸Ð²Ð°Ñ” Ð¿ÐµÑ€ÐµÐºÐ»Ð°Ð´ Ð´Ð°Ð½Ð¾Ð³Ð¾ Ñ€Ð¾Ð·Ð´Ñ–Ð»Ñƒ. ðŸš§ 

Swift Ð¼Ð°Ñ” Ð²Ð±ÑƒÐ´Ð¾Ð²Ð°Ð½Ñƒ Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÑƒ Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ñ Ð°ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾Ð³Ð¾ Ñ‚Ð° Ð¿Ð°Ñ€Ð°Ð»ÐµÐ»ÑŒÐ½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ñƒ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð¾Ð²Ð°Ð½Ð¸Ð¼ Ñ‡Ð¸Ð½Ð¾Ð¼. *ÐÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¸Ð¹ ÐºÐ¾Ð´* Ð¼Ð¾Ð¶Ðµ Ð±ÑƒÑ‚Ð¸ Ð¿Ñ€Ð¸Ð·ÑƒÐ¿Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ñ– Ð¿Ñ€Ð¾Ð´Ð¾Ð²Ð¶ÐµÐ½Ð¸Ð¹ Ð¿Ñ–Ð·Ð½Ñ–ÑˆÐµ, Ñ…Ð¾Ñ‡ Ð»Ð¸ÑˆÐµ Ð¾Ð´Ð¸Ð½Ð° Ñ‡Ð°ÑÑ‚Ð¸Ð½Ð° Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¸ Ð²Ð¸ÐºÐ¾Ð½ÑƒÑ”Ñ‚ÑŒÑÑ Ð² Ð¾Ð´Ð¸Ð½Ð¸Ñ†ÑŽ Ñ‡Ð°ÑÑƒ. ÐŸÑ€Ð¸Ð·ÑƒÐ¿Ð¸Ð½ÐµÐ½Ð½Ñ Ñ– Ð¿Ñ€Ð¾Ð´Ð¾Ð²Ð¶ÐµÐ½Ð½Ñ Ð²Ð¸ÐºÐ¾Ð½Ð°Ð½Ð½Ñ ÐºÐ¾Ð´Ñƒ Ñƒ Ð²Ð°ÑˆÑ–Ð¹ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ñ– Ð´Ð¾Ð·Ð²Ð¾Ð»ÑÑ” Ñ—Ð¹ Ð¿Ñ€Ð¾Ð´Ð¾Ð¶ÑƒÐ²Ð°Ñ‚Ð¸ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑ ÐºÐ¾Ñ‚Ð¾Ñ‚ÐºÐ¾ÑÑ‚Ñ€Ð¾ÐºÐ¾Ð²Ð¸Ñ… Ð¾Ð¿ÐµÑ€Ð°Ñ†Ñ–Ð¹, Ð½Ð° ÐºÑˆÑ‚Ð°Ð»Ñ‚ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ Ñ–Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÑƒ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ð°, Ð¿Ñ€Ð¸ Ñ†ÑŒÐ¾Ð¼Ñƒ Ð¿Ñ€Ð¾Ð´Ð¾Ð²Ð¶ÑƒÑŽÑ‡Ð¸ Ð¿Ñ€Ð°Ñ†ÑŽÐ²Ð°Ñ‚Ð¸ Ð½Ð°Ð´ Ð´Ð¾Ð²Ð³Ð¾ÑÑ‚Ñ€Ð¾ÐºÐ¾Ð²Ð¸Ð¼Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ñ–ÑÐ¼Ð¸, Ð½Ð°Ð¿Ñ€Ð¸ÐºÐ»Ð°Ð´ Ð½Ð°Ð´ Ð²Ð¸ÐºÐ°Ñ‡ÑƒÐ²Ð°Ð½Ð½ÑÐ¼ Ð´Ð°Ð½Ð¸Ñ… Ñ–Ð· Ð¼ÐµÑ€ÐµÐ¶Ñ– Ñ‡Ð¸ Ð½Ð°Ð´ Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³Ð¾Ð¼ Ñ„Ð°Ð¹Ð»Ñ–Ð². *ÐŸÐ°Ñ€Ð°Ð»ÐµÐ»ÑŒÐ½Ð¸Ð¹ ÐºÐ¾Ð´* â€“ Ð¾Ð·Ð½Ð°Ñ‡Ð°Ñ”, Ñ‰Ð¾ Ð´ÐµÐºÑ–Ð»ÑŒÐºÐ° Ñ‡Ð°ÑÑ‚Ð¸Ð½ ÐºÐ¾Ð´Ñƒ Ð¼Ð¾Ð¶ÑƒÑ‚ÑŒ Ð²Ð¸ÐºÐ¾Ð½ÑƒÐ²Ð°Ñ‚Ð¸ÑÑŒ Ð¾Ð´Ð½Ð¾Ñ‡Ð°ÑÐ½Ð¾. ÐÐ°Ð¿Ñ€Ð¸ÐºÐ»Ð°Ð´, ÐºÐ¾Ð¼Ð¿'ÑŽÑ‚ÐµÑ€ Ð· Ñ‡Ð¾Ñ‚Ð¸Ñ€ÑŒÐ¾Ñ…ÑÐ´ÐµÑ€Ð½Ð¸Ð¼ Ð¿Ñ€Ð¾Ñ†ÐµÑÐ¾Ñ€Ð¾Ð¼ Ð¼Ð¾Ð¶Ðµ Ð²Ð¸ÐºÐ¾Ð½ÑƒÐ²Ð°Ñ‚Ð¸ Ñ‡Ð¾Ñ‚Ð¸Ñ€Ð¸ ÑˆÐ¼Ð°Ñ‚ÐºÐ¸ ÐºÐ¾Ð´Ñƒ Ð² Ð¾Ð´Ð¸Ð½ Ñ– Ñ‚Ð¾Ð¹ Ð¶Ðµ Ñ‡Ð°Ñ, Ð²Ð¸Ð´Ñ–Ð»ÑÑŽÑ‡Ð¸ Ð½Ð° ÐºÐ¾Ð¶Ð½Ñƒ Ð·Ð°Ð´Ð°Ñ‡Ñƒ Ð¿Ð¾ ÑÐ´Ñ€Ñƒ. ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¸, Ñ‰Ð¾ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑŽÑ‚ÑŒ Ð¿Ð°Ñ€Ð°Ð»ÐµÐ»ÑŒÐ½Ð¸Ð¹ Ñ‚Ð° Ð°ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¸Ð¹ ÐºÐ¾Ð´, Ð²Ð¸ÐºÐ¾Ð½ÑƒÑŽÑ‚ÑŒ Ð´ÐµÐºÑ–Ð»ÑŒÐºÐ° Ð¾Ð¿ÐµÑ€Ð°Ñ†Ñ–Ð¹ Ð¾Ð´Ð½Ð¾Ñ‡Ð°ÑÐ½Ð¾; Ð²Ð¾Ð½Ð¸ Ð¿Ñ€Ð¸Ð·ÑƒÐ¿Ð¸Ð½ÑÑŽÑ‚ÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ñ–Ñ—, ÐºÐ¾Ñ‚Ñ€Ñ– Ð¾Ñ‡Ñ–ÐºÑƒÑŽÑ‚ÑŒ Ð½Ð° Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´ÑŒ Ð²Ñ–Ð´ Ð·Ð¾Ð²Ð½Ñ–ÑˆÐ½Ñ–Ñ… ÑÐ¸ÑÑ‚ÐµÐ¼, Ñ– Ñ†Ðµ Ñ€Ð¾Ð±Ð¸Ñ‚ÑŒ Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ñ Ñ‚Ð°ÐºÐ¾Ð³Ð¾ ÐºÐ¾Ð´Ñƒ Ð· ÑƒÑ€Ð°Ñ…ÑƒÐ²Ð°Ð½Ð½ÑÐ¼ Ð±ÐµÐ·Ð¿ÐµÐºÐ¸ Ð¿Ð°Ð¼'ÑÑ‚Ñ– Ð»ÐµÐ³ÑˆÐ¸Ð¼. 

Ð’Ñ‚Ñ–Ð¼, Ð´Ð¾Ð´Ð°Ñ‚ÐºÐ¾Ð²Ð° Ð³Ð½ÑƒÑ‡ÐºÑ–ÑÑ‚ÑŒ Ð¿Ð»Ð°Ð½ÑƒÐ²Ð°Ð½Ð½Ñ Ð¿Ð°Ñ€Ð°Ð»ÐµÐ»ÑŒÐ½Ð¾Ð³Ð¾ Ñ‚Ð° Ð°ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ñƒ Ð¼Ð°Ñ” ÑÐ²Ð¾ÑŽ Ñ†Ñ–Ð½Ñƒ, Ñ‰Ð¾ Ð¿Ð¾Ð»ÑÐ³Ð°Ñ” Ñƒ Ð·Ð±Ñ–Ð»ÑŒÑˆÐµÐ½Ñ–Ð¹ ÑÐºÐ»Ð°Ð´Ð½Ð¾ÑÑ‚Ñ–. Swift Ð´Ð¾Ð·Ð²Ð¾Ð»ÑÑ” Ð²Ð°Ð¼ Ð²Ð¸Ñ€Ð°Ð¶Ð°Ñ‚Ð¸ ÑÐ²Ð¾Ñ— Ð½Ð°Ð¼Ñ–Ñ€Ð¸ Ñƒ ÑÐ¿Ð¾ÑÑ–Ð±, Ñ‰Ð¾ Ð¼Ð°Ñ” Ð¿ÐµÐ²Ð½Ñ– Ð¿ÐµÑ€ÐµÐ²Ñ–Ñ€ÐºÐ¸ Ñ‡Ð°ÑÑƒ ÐºÐ¾Ð¼Ð¿Ñ–Ð»ÑÑ†Ñ–Ñ—. ÐÐ°Ð¿Ñ€Ð¸ÐºÐ»Ð°Ð´, Ð²Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾ÑÐ»ÑƒÐ³Ð¾Ð²ÑƒÐ²Ð°Ñ‚Ð¸ÑÑŒ Ð°ÐºÑ‚Ð¾Ñ€Ð°Ð¼Ð¸ Ð´Ð»Ñ Ð±ÐµÐ·Ð¿ÐµÑ‡Ð½Ð¾Ð³Ð¾ Ð·Ð²ÐµÑ€Ð½ÐµÐ½Ð½Ñ Ð´Ð¾ Ð·Ð¼Ñ–Ð½ÑŽÐ²Ð°Ð½Ð¾Ð³Ð¾ ÑÑ‚Ð°Ð½Ñƒ. ÐžÐ´Ð½Ð°Ðº, Ð´Ð¾Ð´Ð°Ð²Ð°Ð½Ð½Ñ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚Ñ– Ð´Ð¾ Ð¿Ð¾Ð²Ñ–Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ñ‡Ð¸ Ð·Ð°Ð±Ð°Ð³Ð¾Ð²Ð°Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ñƒ Ð½Ðµ Ð³Ð°Ñ€Ð°Ð½Ñ‚ÑƒÑ”, Ñ‰Ð¾ Ð²Ñ–Ð½ ÑÑ‚Ð°Ð½Ðµ ÑˆÐ²Ð¸Ð´ÑˆÐ¸Ð¼ Ñ‡Ð¸ ÐºÐ¾Ñ€ÐµÐºÑ‚Ð½Ñ–ÑˆÐ¸Ð¼. Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑˆÐµ Ð·Ð° Ð²ÑÐµ Ð´Ð¾Ð´Ð°Ð²Ð°Ð½Ð½Ñ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚Ñ– Ð¼Ð¾Ð¶Ðµ Ð½Ð°Ð²Ñ–Ñ‚ÑŒ Ð½Ð°ÑˆÐºÐ¾Ð´Ð¸Ñ‚Ð¸, Ð·Ñ€Ð¾Ð±Ð¸Ð²ÑˆÐ¸ Ð²Ð°Ñˆ ÐºÐ¾Ð´ ÑÐºÐ»Ð°Ð´Ð½Ð¸Ð¼ Ð´Ð»Ñ Ð·Ð½ÐµÐ²Ð°Ð´Ð¶ÐµÐ½Ð½Ñ. ÐžÐ´Ð½Ð°Ðº, Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ð½Ð½Ñ Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÐ¸ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚Ñ– Ð½Ð° Ñ€Ñ–Ð²Ð½Ñ– Ð¼Ð¾Ð²Ð¸ Swift Ñƒ Ñ‚Ð¾Ð¼Ñƒ Ð²Ð°ÑˆÐ¾Ð¼Ñƒ ÐºÐ¾Ð´Ñ–, ÑÐºÐ¸Ð¹ Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð±ÑƒÑ‚Ð¸ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ð¸Ð¼, Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð¶Ðµ Ð²Ð°Ð¼ Ð·Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚Ð¸ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð¸ Ð¿Ñ–Ð´ Ñ‡Ð°Ñ ÐºÐ¾Ð¼Ð¿Ñ–Ð»ÑÑ†Ñ–Ñ—.

Ð ÐµÑˆÑ‚Ð° Ñ†ÑŒÐ¾Ð³Ð¾ Ñ€Ð¾Ð·Ð´Ñ–Ð»Ñƒ Ð±ÑƒÐ´Ðµ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÐ²Ð°Ñ‚Ð¸ Ñ‚ÐµÑ€Ð¼Ñ–Ð½ *ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ñ–ÑÑ‚ÑŒ* Ð´Ð»Ñ Ð¿Ð¾Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ ÐºÐ¾Ð¼Ð±Ñ–Ð½Ð°Ñ†Ñ–Ñ— Ð°ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾Ð³Ð¾ Ñ– Ð¿Ð°Ñ€Ð°Ð»ÐµÐ»ÑŒÐ½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ñƒ.

> **ÐŸÑ€Ð¸Ð¼Ñ–Ñ‚ÐºÐ°** 
>
> Ð¯ÐºÑ‰Ð¾ Ð²Ð¸ Ð¿Ð¸ÑÐ°Ð»Ð¸ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ð¸Ð¹ ÐºÐ¾Ð´ Ñ€Ð°Ð½Ñ–ÑˆÐµ, Ð²Ð¸, Ð¿ÐµÐ²Ð½Ðµ, Ð·Ð²Ð¸ÐºÐ½ÑƒÑ‚Ð¸ Ð¿Ñ€Ð°Ñ†ÑŽÐ²Ð°Ñ‚Ð¸ Ð· Ð¿Ð¾Ñ‚Ð¾ÐºÐ°Ð¼Ð¸. ÐœÐ¾Ð´ÐµÐ»ÑŒ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚Ñ– Ñƒ Swift Ð¿Ð¾Ð±ÑƒÐ´Ð¾Ð²Ð°Ð½Ð° Ð¿Ð¾Ð²ÐµÑ€Ñ… Ð¿Ð¾Ñ‚Ð¾ÐºÑ–Ð², Ð°Ð»Ðµ Ð²Ð¸ Ð½Ðµ Ð²Ð·Ð°Ñ”Ð¼Ð¾Ð´Ñ–Ñ”Ñ‚Ðµ Ð· Ð½Ð¸Ð¼Ð¸ Ð½Ð°Ð¿Ñ€ÑÐ¼Ñƒ. ÐÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð° Ñ„ÑƒÐ½ÐºÑ†Ñ–Ñ Ñƒ Swift Ð¼Ð¾Ð¶Ðµ Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð¸Ñ‚Ð¸ÑÑŒ Ð¿Ð¾Ñ‚Ð¾ÐºÐ¾Ð¼, Ð½Ð° ÑÐºÐ¾Ð¼Ñƒ Ð²Ð¾Ð½Ð° Ð²Ð¸ÐºÐ¾Ð½ÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ Ð´Ð¾Ð·Ð²Ð¾Ð»ÑÑ” Ñ–Ð½ÑˆÑ–Ð¹ Ð°ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ñ–Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ñ–Ñ— Ð¿Ñ€Ð°Ñ†ÑŽÐ²Ð°Ñ‚Ð¸ Ð½Ð° Ñ†ÑŒÐ¾Ð¼Ñƒ Ð¿Ð¾Ñ‚Ð¾Ñ†Ñ– Ð´Ð¾Ð¿Ð¾ÐºÐ¸ Ð¿ÐµÑ€ÑˆÐ° Ñ„ÑƒÐ½ÐºÑ†Ñ–Ñ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð°. ÐšÐ¾Ð»Ð¸ Ð°ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¸Ð¹ ÐºÐ¾Ð´ Ð¿Ñ€Ð¾Ð´Ð¾Ð²Ð¶Ð¸Ñ‚ÑŒÑÑ, Swift Ð½Ðµ Ð´Ð°Ñ” Ð¶Ð¾Ð´Ð½Ð¸Ñ… Ð³Ð°Ñ€Ð°Ð½Ñ‚Ñ–Ð¹ Ñ‰Ð¾Ð´Ð¾ Ñ‚Ð¾Ð³Ð¾, Ð½Ð° ÑÐºÐ¾Ð¼Ñƒ Ð¿Ð¾Ñ‚Ð¾Ñ†Ñ– Ñ„ÑƒÐ½ÐºÑ†Ñ–Ñ Ð¿Ñ€Ð°Ñ†ÑŽÐ²Ð°Ñ‚Ð¸Ð¼Ðµ Ð´Ð°Ð»Ñ–.

Ð¥Ð¾Ñ‡ Ñ– Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð¿Ð¸ÑÐ°Ñ‚Ð¸ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð½Ð¸Ð¹ ÐºÐ¾Ð´ Ð±ÐµÐ· Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÐ¸ Ð½Ð° Ñ€Ñ–Ð²Ð½Ñ– Ð¼Ð¾Ð²Ð¸ Swift, Ñ†ÐµÐ¹ ÐºÐ¾Ð´ ÑÐº Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð¾ ÑÐºÐ»Ð°Ð´Ð½Ñ–ÑˆÐµ Ñ‡Ð¸Ñ‚Ð°Ñ‚Ð¸. ÐÐ°Ð¿Ñ€Ð¸ÐºÐ»Ð°Ð´, ÐºÐ¾Ð´ Ð½Ð¸Ð¶Ñ‡Ðµ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÑƒÑ” ÑÐ¿Ð¸ÑÐ¾Ðº Ð½Ð°Ð·Ð² Ñ„Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ñ–Ð¹, Ð¿Ð¾Ñ‚Ñ–Ð¼ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÑƒÑ” Ð¿ÐµÑ€ÑˆÐµ Ñ„Ð¾Ñ‚Ð¾ Ð·Ñ– ÑÐ¿Ð¸ÑÐºÑƒ, Ñ‚Ð° Ð¿Ð¾ÐºÐ°Ð·ÑƒÑ” Ñ†Ðµ Ñ„Ð¾Ñ‚Ð¾ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ñƒ:

```swift
listPhotos(inGallery: "Summer Vacation") { photoNames in
    let sortedNames = photoNames.sorted()
    let name = sortedNames[0]
    downloadPhoto(named: name) { photo in
        show(photo)
    }
}
```

ÐÐ°Ð²Ñ–Ñ‚ÑŒ Ñƒ Ñ†ÑŒÐ¾Ð¼Ñƒ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð²Ð¸Ð¿Ð°Ð´ÐºÑƒ, ÐºÐ¾Ð´ Ð¿Ð¾Ñ‚Ñ€Ñ–Ð±Ð½Ð¾ Ð¿Ð¸ÑÐ°Ñ‚Ð¸ ÑÐº Ð¿Ð¾ÑÐ»Ñ–Ð´Ð¾Ð²Ð½Ñ–ÑÑ‚ÑŒ Ð¾Ð±Ñ€Ð¾Ð±Ð½Ð¸ÐºÑ–Ð² Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½ÑŒ, Ð¿Ñ€Ð¸Ð·Ð²Ð¾Ð´ÑÑ‡Ð¸ Ð´Ð¾ Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ñ Ð²ÐºÐ»Ð°Ð´ÐµÐ½Ð¸Ñ… Ð·Ð°Ð¼Ð¸ÐºÐ°Ð½ÑŒ. Ð£ Ñ†ÑŒÐ¾Ð¼Ñƒ ÑÑ‚Ð¸Ð»Ñ–, ÑÐºÐ»Ð°Ð´Ð½Ñ–ÑˆÐ¸Ð¹ ÐºÐ¾Ð´ Ñ–Ð· Ð³Ð»Ð¸Ð±ÑˆÐ¸Ð¼ Ñ€Ñ–Ð²Ð½ÐµÐ¼ Ð²ÐºÐ»Ð°Ð´ÐµÐ½Ð½Ñ Ð¼Ð¾Ð¶Ðµ ÑˆÐ²Ð¸Ð´ÐºÐ¾ ÑÑ‚Ð°Ñ‚Ð¸ Ð½ÐµÐ¿Ñ–Ð´Ð¹Ð¾Ð¼Ð½Ð¸Ð¼. 

## Defining and Calling Asynchronous Functions

An *asynchronous function* or *asynchronous method* is a special kind of function or method that can be suspended while it's partway through execution. This is in contrast to ordinary, synchronous functions and methods, which either run to completion, throw an error, or never return. An asynchronous function or method still does one of those three things, but it can also pause in the middle when it's waiting for something. Inside the body of an asynchronous function or method, you mark each of these places where execution can be suspended.

To indicate that a function or method is asynchronous, you write the `async` keyword in its declaration after its parameters, similar to how you use `throws` to mark a throwing function. If the function or method returns a value, you write `async` before the return arrow (`->`). For example, here's how you might fetch the names of photos in a gallery:

```swift
func listPhotos(inGallery name: String) async -> [String] {
    let result = // ... some asynchronous networking code ...
    return result
}
```

For a function or method that's both asynchronous and throwing, you write `async` before `throws`.

When calling an asynchronous method, execution suspends until that method returns. You write `await` in front of the call to mark the possible suspension point. This is like writing `try` when calling a throwing function, to mark the possible change to the program's flow if there's an error. Inside an asynchronous method, the flow of execution is suspended *only* when you call another asynchronous method --- suspension is never implicit or preemptive --- which means every possible suspension point is marked with `await`.

For example, the code below fetches the names of all the pictures in a gallery and then shows the first picture:

```swift
let photoNames = await listPhotos(inGallery: "Summer Vacation")
let sortedNames = photoNames.sorted()
let name = sortedNames[0]
let photo = await downloadPhoto(named: name)
show(photo)
```

Because the `listPhotos(inGallery:)` and `downloadPhoto(named:)` functions both need to make network requests, they could take a relatively long time to complete. Making them both asynchronous by writing `async` before the return arrow lets the rest of the app's code keep running while this code waits for the picture to be ready.

To understand the concurrent nature of the example above, here's one possible order of execution:

- The code starts running from the first line and runs up to the first `await`. It calls the `listPhotos(inGallery:)` function and suspends execution while it waits for that function to return.
- While this code's execution is suspended, some other concurrent code in the same program runs. For example, maybe a long-running background task continues updating a list of new photo galleries. That code also runs until the next suspension point, marked by `await`, or until it completes.
- After `listPhotos(inGallery:)` returns, this code continues execution starting at that point. It assigns the value that was returned to `photoNames`.
- The lines that define `sortedNames` and `name` are regular, synchronous code. Because nothing is marked `await` on these lines,
  there aren't any possible suspension points.
- The next `await` marks the call to the `downloadPhoto(named:)` function. This code pauses execution again until that function returns, giving other concurrent code an opportunity to run.
- After `downloadPhoto(named:)` returns, its return value is assigned to `photo` and then passed as an argument when calling `show(_:)`.

The possible suspension points in your code marked with `await` indicate that the current piece of code might pause execution while waiting for the asynchronous function or method to return. This is also called *yielding the thread* because, behind the scenes, Swift suspends the execution of your code on the current thread and runs some other code on that thread instead. Because code with `await` needs to be able to suspend execution, only certain places in your program can call asynchronous functions or methods:

- Code in the body of an asynchronous function, method, or property.
- Code in the static `main()` method of
  a structure, class, or enumeration that's marked with `@main`.
- Code in an unstructured child task, as shown in <doc:Concurrency#Unstructured-Concurrency> below.

<!--
  SE-0296 specifically calls out that top-level code is *not* an async context,
  contrary to what you might expect.
  If that gets changed, add this bullet to the list above:

  - Code at the top level that forms an implicit main function.
    -->

Code in between possible suspension points runs sequentially, without the possibility of interruption from other concurrent code. For example, the code below moves a picture from one gallery to another.

```swift
let firstPhoto = await listPhotos(inGallery: "Summer Vacation")[0]
add(firstPhoto, toGallery: "Road Trip")
// At this point, firstPhoto is temporarily in both galleries.
remove(firstPhoto, fromGallery: "Summer Vacation")
```

There's no way for other code to run in between the call to `add(_:toGallery:)` and `remove(_:fromGallery:)`. During that time, the first photo appears in both galleries, temporarily breaking one of the app's invariants. To make it even clearer that this chunk of code must not have `await` added to it in the future, you can refactor that code into a synchronous function:

```swift
func move(_ photoName: String, from source: String, to destination: String) {
    add(photoName, toGallery: destination)
    remove(photoName, fromGallery: source)
}
// ...
let firstPhoto = await listPhotos(inGallery: "Summer Vacation")[0]
move(firstPhoto, from: "Summer Vacation", to: "Road Trip")
```

In the example above, because the `move(_:from:to:)` function is synchronous, you guarantee that it can never contain possible suspension points. In the future, if you try to add concurrent code to this function, introducing a possible suspension point, you'll get compile-time error instead of introducing a bug.

> **Note** 
>
> The [`Task.sleep(until:tolerance:clock:)`](https://developer.apple.com/documentation/swift/task/sleep(until:tolerance:clock:)) method is useful when writing simple code to learn how concurrency works. This method does nothing, but waits at least the given number of nanoseconds before it returns. Here's a version of the `listPhotos(inGallery:)` function that uses `sleep(until:tolerance:clock:)` to simulate waiting for a network operation:
>
> ```swift
> func listPhotos(inGallery name: String) async throws -> [String] {
>     try await Task.sleep(until: .now + .seconds(2), clock: .continuous)
>     return ["IMG001", "IMG99", "IMG0404"]
> }
> ```

## Asynchronous Sequences

The `listPhotos(inGallery:)` function in the previous section asynchronously returns the whole array at once, after all of the array's elements are ready. Another approach is to wait for one element of the collection at a time using an *asynchronous sequence*. Here's what iterating over an asynchronous sequence looks like:

```swift
import Foundation

let handle = FileHandle.standardInput
for try await line in handle.bytes.lines {
    print(line)
}
```

Instead of using an ordinary `for`-`in` loop, the example above writes `for` with `await` after it. Like when you call an asynchronous function or method, writing `await` indicates a possible suspension point. A `for`-`await`-`in` loop potentially suspends execution at the beginning of each iteration, when it's waiting for the next element to be available.

In the same way that you can use your own types in a `for`-`in` loop by adding conformance to the [`Sequence`](https://developer.apple.com/documentation/swift/sequence) protocol, you can use your own types in a `for`-`await`-`in` loop by adding conformance to the [`AsyncSequence`](https://developer.apple.com/documentation/swift/asyncsequence) protocol.

## Calling Asynchronous Functions in Parallel

Calling an asynchronous function with `await` runs only one piece of code at a time. While the asynchronous code is running, the caller waits for that code to finish before moving on to run the next line of code. For example, to fetch the first three photos from a gallery, you could await three calls to the `downloadPhoto(named:)` function as follows:

```swift
let firstPhoto = await downloadPhoto(named: photoNames[0])
let secondPhoto = await downloadPhoto(named: photoNames[1])
let thirdPhoto = await downloadPhoto(named: photoNames[2])

let photos = [firstPhoto, secondPhoto, thirdPhoto]
show(photos)
```

This approach has an important drawback: Although the download is asynchronous and lets other work happen while it progresses, only one call to `downloadPhoto(named:)` runs at a time. Each photo downloads completely before the next one starts downloading. However, there's no need for these operations to wait --- each photo can download independently, or even at the same time.

To call an asynchronous function and let it run in parallel with code around it, write `async` in front of `let` when you define a constant, and then write `await` each time you use the constant.

```swift
async let firstPhoto = downloadPhoto(named: photoNames[0])
async let secondPhoto = downloadPhoto(named: photoNames[1])
async let thirdPhoto = downloadPhoto(named: photoNames[2])

let photos = await [firstPhoto, secondPhoto, thirdPhoto]
show(photos)
```

In this example, all three calls to `downloadPhoto(named:)` start without waiting for the previous one to complete. If there are enough system resources available, they can run at the same time. None of these function calls are marked with `await` because the code doesn't suspend to wait for the function's result. Instead, execution continues until the line where `photos` is defined --- at that point, the program needs the results from these asynchronous calls, so you write `await` to pause execution until all three photos finish downloading.

Here's how you can think about the differences between these two approaches:

- Call asynchronous functions with `await` when the code on the following lines depends on that function's result. This creates work that is carried out sequentially.
- Call asynchronous functions with `async`-`let` when you don't need the result until later in your code. This creates work that can be carried out in parallel.
- Both `await` and `async`-`let` allow other code to run while they're suspended.
- In both cases, you mark the possible suspension point with `await` to indicate that execution will pause, if needed, until an asynchronous function has returned.

You can also mix both of these approaches in the same code.

## Tasks and Task Groups

A *task* is a unit of work that can be run asynchronously as part of your program. All asynchronous code runs as part of some task. The `async`-`let` syntax described in the previous section creates a child task for you. You can also create a task group and add child tasks to that group, which gives you more control over priority and cancellation, and lets you create a dynamic number of tasks.

Tasks are arranged in a hierarchy. Each task in a task group has the same parent task, and each task can have child tasks. Because of the explicit relationship between tasks and task groups, this approach is called *structured concurrency*. Although you take on some of the responsibility for correctness, the explicit parent-child relationships between tasks let Swift handle some behaviors like propagating cancellation for you, and lets Swift detect some errors at compile time.

```swift
await withTaskGroup(of: Data.self) { taskGroup in
    let photoNames = await listPhotos(inGallery: "Summer Vacation")
    for name in photoNames {
        taskGroup.addTask { await downloadPhoto(named: name) }
    }
}
```

For more information about task groups, see [`TaskGroup`](https://developer.apple.com/documentation/swift/taskgroup).

### Unstructured Concurrency

In addition to the structured approaches to concurrency described in the previous sections, Swift also supports unstructured concurrency. Unlike tasks that are part of a task group, an *unstructured task* doesn't have a parent task. You have complete flexibility to manage unstructured tasks in whatever way your program needs, but you're also completely responsible for their correctness. To create an unstructured task that runs on the current actor, call the [`Task.init(priority:operation:)`](https://developer.apple.com/documentation/swift/task/3856790-init) initializer. To create an unstructured task that's not part of the current actor, known more specifically as a *detached task*, call the [`Task.detached(priority:operation:)`](https://developer.apple.com/documentation/swift/task/3856786-detached) class method. Both of these operations return a task that you can interact with --- for example, to wait for its result or to cancel it.

```swift
let newPhoto = // ... some photo data ...
let handle = Task {
    return await add(newPhoto, toGalleryNamed: "Spring Adventures")
}
let result = await handle.value
```

For more information about managing detached tasks, see [`Task`](https://developer.apple.com/documentation/swift/task).

### Task Cancellation

Swift concurrency uses a cooperative cancellation model. Each task checks whether it has been canceled at the appropriate points in its execution, and responds to cancellation in whatever way is appropriate. Depending on the work you're doing, that usually means one of the following:

- Throwing an error like `CancellationError`
- Returning `nil` or an empty collection
- Returning the partially completed work

To check for cancellation, either call [`Task.checkCancellation()`](https://developer.apple.com/documentation/swift/task/3814826-checkcancellation), which throws `CancellationError` if the task has been canceled, or check the value of [`Task.isCancelled`](https://developer.apple.com/documentation/swift/task/3814832-iscancelled) and handle the cancellation in your own code. For example, a task that's downloading photos from a gallery might need to delete partial downloads and close network connections.

To propagate cancellation manually, call [`Task.cancel()`](https://developer.apple.com/documentation/swift/task/3851218-cancel).

## Actors

You can use tasks to break up your program into isolated, concurrent pieces. Tasks are isolated from each other, which is what makes it safe for them to run at the same time, but sometimes you need to share some information between tasks. Actors let you safely share information between concurrent code.

Like classes, actors are reference types, so the comparison of value types and reference types in <doc:ClassesAndStructures#Classes-Are-Reference-Types> applies to actors as well as classes. Unlike classes, actors allow only one task to access their mutable state at a time, which makes it safe for code in multiple tasks to interact with the same instance of an actor. For example, here's an actor that records temperatures:

```swift
actor TemperatureLogger {
    let label: String
    var measurements: [Int]
    private(set) var max: Int

    init(label: String, measurement: Int) {
        self.label = label
        self.measurements = [measurement]
        self.max = measurement
    }
}
```

You introduce an actor with the `actor` keyword, followed by its definition in a pair of braces. The `TemperatureLogger` actor has properties that other code outside the actor can access, and restricts the `max` property so only code inside the actor can update the maximum value.

You create an instance of an actor using the same initializer syntax as structures and classes. When you access a property or method of an actor, you use `await` to mark the potential suspension point. For example:

```swift
let logger = TemperatureLogger(label: "Outdoors", measurement: 25)
print(await logger.max)
// Prints "25"
```

In this example, accessing `logger.max` is a possible suspension point. Because the actor allows only one task at a time to access its mutable state, if code from another task is already interacting with the logger, this code suspends while it waits to access the property.

In contrast, code that's part of the actor doesn't write `await` when accessing the actor's properties. For example, here's a method that updates a `TemperatureLogger` with a new temperature:

```swift
extension TemperatureLogger {
    func update(with measurement: Int) {
        measurements.append(measurement)
        if measurement > max {
            max = measurement
        }
    }
}
```

The `update(with:)` method is already running on the actor, so it doesn't mark its access to properties like `max` with `await`. This method also shows one of the reasons why actors allow only one task at a time to interact with their mutable state: Some updates to an actor's state temporarily break invariants. The `TemperatureLogger` actor keeps track of a list of temperatures and a maximum temperature, and it updates the maximum temperature when you record a new measurement. In the middle of an update, after appending the new measurement but before updating `max`, the temperature logger is in a temporary inconsistent state. Preventing multiple tasks from interacting with the same instance simultaneously prevents problems like the following sequence of events:

1. Your code calls the `update(with:)` method. It updates the `measurements` array first.
2. Before your code can update `max`, code elsewhere reads the maximum value and the array of temperatures.
3. Your code finishes its update by changing `max`.

In this case, the code running elsewhere would read incorrect information because its access to the actor was interleaved in the middle of the call to `update(with:)` while the data was temporarily invalid. You can prevent this problem when using Swift actors because they only allow one operation on their state at a time, and because that code can be interrupted only in places where `await` marks a suspension point. Because `update(with:)` doesn't contain any suspension points, no other code can access the data in the middle of an update.

If you try to access those properties from outside the actor, like you would with an instance of a class, you'll get a compile-time error. For example:

```swift
print(logger.max)  // Error
```

Accessing `logger.max` without writing `await` fails because the properties of an actor are part of that actor's isolated local state. Swift guarantees that only code inside an actor can access the actor's local state. This guarantee is known as *actor isolation*.

## Sendable Types

Tasks and actors let you divide a program into pieces that can safely run concurrently. Inside of a task or an instance of an actor, the part of a program that contains mutable state, like variables and properties, is called a *concurrency domain*. Some kinds of data can't be shared between concurrency domains, because that data contains mutable state, but it doesn't protect against overlapping access.

A type that can be shared from one concurrency domain to another is known as a *sendable* type. For example, it can be passed as an argument when calling an actor method or be returned as the result of a task. The examples earlier in this chapter didn't discuss sendability because those examples use simple value types that are always safe to share for the data being passed between concurrency domains. In contrast, some types aren't safe to pass across concurrency domains. For example, a class that contains mutable properties and doesn't serialize access to those properties can produce unpredictable and incorrect results when you pass instances of that class between different tasks.

You mark a type as being sendable by declaring conformance to the `Sendable` protocol. That protocol doesn't have any code requirements, but it does have semantic requirements that Swift enforces. In general, there are three ways for a type to be sendable:

- The type is a value type, and its mutable state is made up of other sendable data --- for example, a structure with stored properties that are sendable or an enumeration with associated values that are sendable.
- The type doesn't have any mutable state, and its immutable state is made up of other sendable data --- for example, a structure or class that has only read-only properties.
- The type has code that ensures the safety of its mutable state, like a class that's marked `@MainActor` or a class that serializes access to its properties on a particular thread or queue.

For a detailed list of the semantic requirements, see the [`Sendable`](https://developer.apple.com/documentation/swift/sendable) protocol reference.

Some types are always sendable, like structures that have only sendable properties and enumerations that have only sendable associated values. For example:

```swift
struct TemperatureReading: Sendable {
    var measurement: Int
}

extension TemperatureLogger {
    func addReading(from reading: TemperatureReading) {
        measurements.append(reading.measurement)
    }
}

let logger = TemperatureLogger(label: "Tea kettle", measurement: 85)
let reading = TemperatureReading(measurement: 45)
await logger.addReading(from: reading)
```

Because `TemperatureReading` is a structure that has only sendable properties, and the structure isn't marked `public` or `@usableFromInline`, it's implicitly sendable. Here's a version of the structure where conformance to the `Sendable` protocol is implied:

```swift
struct TemperatureReading {
    var measurement: Int
}
```
